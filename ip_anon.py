import re
import ipaddress

def list_iter(a_list):
    '''
    Generator function that takes a list as input.
    Checks if items in list can be split into 4 . separated octets and if mask is /24 or 0.0.0.0 and yields the item.
    Expand this using binary conversion to evaluate for IP MASK pairings.
    '''
    for item in a_list:
       if (len(item.split('.')) == 4) and '0.0.0.0' not in item:
           yield item

class IPAnon:
    def __init__(self, config):
        with open(config) as f:
            config_lines = f.readlines()
        self.config_lines = config_lines

    def ip_guess(self):
        possible_ips = []
        for line in self.config_lines:
            splitline = line.split()
            for item in splitline:
                if (len(item.split('.')) == 4) and '0.0.0.0' not in item:
                    possible_ips.append(item)
        self.possible_ips = possible_ips

    def ip_address_list(self):
        '''
        Go through list of IPs generated by ip_guess.
        List interface objects e.g: ip address 1.1.1.1 netmask 255.255.255.0
        List host addresses e.g: tcp host 1.1.1.1
        '''
        config_hosts = []
        config_interfaces = []
        #print self.possible_ips
        
        for i, address  in enumerate(self.possible_ips):
            try:
                try_address = '{}/{}'.format(address, self.possible_ips[i+1])
                print('tryng: {}'.format(try_address))
                test_add = ipaddress.IPv4Interface('{}/{}'.format(address, self.possible_ips[i+1]))
                config_interfaces.append(test_add)
                #networks_and_interfaces.append('')
            except ipaddress.NetmaskValueError:
                curr_address = ipaddress.IPv4Address(address).packed
                flatbits = ''
                for b in curr_address:
                    bits = format(int(b), '08b')
                    flatbits = '{}{}'.format(flatbits, str(bits))
                match = re.match('(1+)?(0+)?$', flatbits)
                if match:
                    print ('Evaluating: {}'.format(flatbits))
                else:
                    print('Evaluating: {}'.format(address))
                    config_hosts.append(address)
            except IndexError:
                print('End of List')
        print('interface objects: {}'.format(config_interfaces))
        print('addresses: {}'.format(config_hosts))
        self.config_hosts = config_hosts
        self.config_interfaces = config_interfaces

def main():
    #testwords = ['1.10.100.101', 'ladybirds', 'hello.word']
    with open('sample_conf.txt') as f:
        f_lines = f.readlines()
        f_split_lines = [i.split() for i in f_lines]

    #print f_split_lines
    all_ips = []
    for i in f_split_lines:
        for j in list_iter(i):
            all_ips.append(j)
    #print('{} \n IPs are: {}'.format(80 * '#', all_ips))

    test_anon_class = IPAnon('sample_conf.txt')
    #print test_anon_class.config_lines
    test_anon_class.ip_guess()
    #print test_anon_class.possible_ips
    test_anon_class.ip_address_list()

if __name__ == '__main__':
    main()
